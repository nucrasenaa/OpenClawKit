// Generated by Scripts/protocol-gen-swift.mjs â€” do not edit by hand
import Foundation

public let GATEWAY_PROTOCOL_VERSION = 3

public enum ErrorCode: String, Codable, Sendable {
    case notLinked = "NOT_LINKED"
    case notPaired = "NOT_PAIRED"
    case agentTimeout = "AGENT_TIMEOUT"
    case invalidRequest = "INVALID_REQUEST"
    case unavailable = "UNAVAILABLE"
}


public struct ConnectParams: Codable, Sendable {
    public let minProtocol: Int
    public let maxProtocol: Int
    public let client: [String: AnyCodable]
    public let caps: [String]?
    public let commands: [String]?
    public let permissions: [String: AnyCodable]?
    public let pathEnv: String?
    public let role: String?
    public let scopes: [String]?
    public let device: [String: AnyCodable]?
    public let auth: [String: AnyCodable]?

    public init(
        minProtocol: Int,
        maxProtocol: Int,
        client: [String: AnyCodable],
        caps: [String]?,
        commands: [String]?,
        permissions: [String: AnyCodable]?,
        pathEnv: String?,
        role: String?,
        scopes: [String]?,
        device: [String: AnyCodable]?,
        auth: [String: AnyCodable]?
    ) {
        self.minProtocol = minProtocol
        self.maxProtocol = maxProtocol
        self.client = client
        self.caps = caps
        self.commands = commands
        self.permissions = permissions
        self.pathEnv = pathEnv
        self.role = role
        self.scopes = scopes
        self.device = device
        self.auth = auth
    }

    private enum CodingKeys: String, CodingKey {
        case minProtocol
        case maxProtocol
        case client
        case caps
        case commands
        case permissions
        case pathEnv
        case role
        case scopes
        case device
        case auth
    }
}

public struct RequestFrame: Codable, Sendable {
    public let type: String
    public let id: String
    public let method: String
    public let params: AnyCodable?

    public init(
        type: String,
        id: String,
        method: String,
        params: AnyCodable?
    ) {
        self.type = type
        self.id = id
        self.method = method
        self.params = params
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case id
        case method
        case params
    }
}

public struct ResponseFrame: Codable, Sendable {
    public let type: String
    public let id: String
    public let ok: Bool
    public let payload: AnyCodable?
    public let error: ErrorShape?

    public init(
        type: String,
        id: String,
        ok: Bool,
        payload: AnyCodable?,
        error: ErrorShape?
    ) {
        self.type = type
        self.id = id
        self.ok = ok
        self.payload = payload
        self.error = error
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case id
        case ok
        case payload
        case error
    }
}

public struct EventFrame: Codable, Sendable {
    public let type: String
    public let event: String
    public let payload: AnyCodable?
    public let seq: Int?

    public init(
        type: String,
        event: String,
        payload: AnyCodable?,
        seq: Int?
    ) {
        self.type = type
        self.event = event
        self.payload = payload
        self.seq = seq
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case event
        case payload
        case seq
    }
}

public struct ErrorShape: Codable, Sendable {
    public let code: ErrorCode
    public let message: String

    public init(
        code: ErrorCode,
        message: String
    ) {
        self.code = code
        self.message = message
    }

    private enum CodingKeys: String, CodingKey {
        case code
        case message
    }
}

public enum GatewayFrame: Codable, Sendable {
    case req(RequestFrame)
    case res(ResponseFrame)
    case event(EventFrame)

    private enum CodingKeys: String, CodingKey {
        case type
    }

    public init(from decoder: Decoder) throws {
        let typeContainer = try decoder.container(keyedBy: CodingKeys.self)
        let type = try typeContainer.decode(String.self, forKey: .type)
        switch type {
        case "req":
            self = .req(try RequestFrame(from: decoder))
        case "res":
            self = .res(try ResponseFrame(from: decoder))
        case "event":
            self = .event(try EventFrame(from: decoder))
        default:
            throw DecodingError.dataCorruptedError(
                forKey: .type,
                in: typeContainer,
                debugDescription: "Unsupported frame type: \(type)"
            )
        }
    }

    public func encode(to encoder: Encoder) throws {
        switch self {
        case .req(let value):
            try value.encode(to: encoder)
        case .res(let value):
            try value.encode(to: encoder)
        case .event(let value):
            try value.encode(to: encoder)
        }
    }
}
