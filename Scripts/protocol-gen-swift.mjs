#!/usr/bin/env node
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const here = path.dirname(fileURLToPath(import.meta.url));
const root = path.resolve(here, "..");
const schemaPath = path.join(here, "protocol-schema.json");
const outPath = path.join(root, "Sources", "OpenClawProtocol", "GatewayModels.swift");

const schema = JSON.parse(await fs.readFile(schemaPath, "utf8"));

const reserved = new Set(["protocol"]);

function safeField(name) {
  return reserved.has(name) ? `_${name}` : name;
}

function codingKeyLine(field) {
  const swiftName = safeField(field.name);
  if (swiftName === field.name) {
    return `        case ${swiftName}`;
  }
  return `        case ${swiftName} = "${field.name}"`;
}

function emitStruct(structDef) {
  const lines = [];
  lines.push(`public struct ${structDef.name}: Codable, Sendable {`);
  for (const field of structDef.fields) {
    lines.push(`    public let ${safeField(field.name)}: ${field.type}`);
  }
  lines.push("");
  lines.push("    public init(");
  lines.push(
    structDef.fields
      .map((field) => `        ${safeField(field.name)}: ${field.type}`)
      .join(",\n")
  );
  lines.push("    ) {");
  for (const field of structDef.fields) {
    const swiftName = safeField(field.name);
    lines.push(`        self.${swiftName} = ${swiftName}`);
  }
  lines.push("    }");
  lines.push("");
  lines.push("    private enum CodingKeys: String, CodingKey {");
  for (const field of structDef.fields) {
    lines.push(codingKeyLine(field));
  }
  lines.push("    }");
  lines.push("}");
  lines.push("");
  return lines.join("\n");
}

function emitGatewayFrame() {
  return `public enum GatewayFrame: Codable, Sendable {
    case req(RequestFrame)
    case res(ResponseFrame)
    case event(EventFrame)

    private enum CodingKeys: String, CodingKey {
        case type
    }

    public init(from decoder: Decoder) throws {
        let typeContainer = try decoder.container(keyedBy: CodingKeys.self)
        let type = try typeContainer.decode(String.self, forKey: .type)
        switch type {
        case "req":
            self = .req(try RequestFrame(from: decoder))
        case "res":
            self = .res(try ResponseFrame(from: decoder))
        case "event":
            self = .event(try EventFrame(from: decoder))
        default:
            throw DecodingError.dataCorruptedError(
                forKey: .type,
                in: typeContainer,
                debugDescription: "Unsupported frame type: \\(type)"
            )
        }
    }

    public func encode(to encoder: Encoder) throws {
        switch self {
        case .req(let value):
            try value.encode(to: encoder)
        case .res(let value):
            try value.encode(to: encoder)
        case .event(let value):
            try value.encode(to: encoder)
        }
    }
}
`;
}

const header = `// Generated by Scripts/protocol-gen-swift.mjs â€” do not edit by hand
import Foundation

public let GATEWAY_PROTOCOL_VERSION = ${schema.protocolVersion}

public enum ErrorCode: String, Codable, Sendable {
${schema.errorCodes
  .map((code) => `    case ${code.toLowerCase().replace(/_([a-z])/g, (_, c) => c.toUpperCase())} = "${code}"`)
  .join("\n")}
}

`;

const body = [
  header,
  ...schema.structs.map(emitStruct),
  emitGatewayFrame(),
].join("\n");

await fs.writeFile(outPath, body);
console.log(`Wrote ${outPath}`);

